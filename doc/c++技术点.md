# C++ 技术点

## 1. 谈谈你对命名空间的理解

- namespace 是一个关键字：随着工程量的增加，变量命名上不可避免出现重名，防止名称冲突（在不同的命名空间中，即使 2 个变量名相同，也是 2 个不同的变量），在实际工作中，基本都使用标准命名空间
- 命名空间只能 **全局范围内** 定义，不能定义在函数内部
- 命名空间内， 可以存放 **变量、函数、结构体、类；也可以嵌套其他的命名空间**
- 命名空间可以 **匿名**（一般不这样使用），类似静态全局变量
- 命名空间是可以 **起别名** 的。

## 2. 谈谈指针与引用的区别

- 引用是给变量起别名，内部实现是指针常量 (int* const ref = &a), 其可以简单的理解为本体指针存放的是变量的地址
- 引用的本质是指针常量，其指向不可修改，而指针可以改变指向
- 引用创建的同时 **必须初始化** ，指针创建的时候可以不必初始化
- 引用不能为空，指针可以为 NULL
- “引用变量 ref“的内存单元保存的是"被引用变量 a "的地址
- sizeof（引用） = 指向变量的大小；sizeof（指针） = 指针本身大大小
- 引用使用的时候无需解引用，指针需要解引用
- 指针和引用“自增/自减运算“意义不一样
- 在同等需求下，函数传参，引用可以将一级指针

## 3. 谈谈你对内联函数的理解

- 宏函数缺陷 1：需要将实现“加 括号”，以保证优先级的完整性
- 宏函数缺陷 2：即使加了括号，有些情况，依然有缺陷
- 内联函数本身是一个真正的函数，但宏函数不是函数
- 内联函数具有普通函数的所有行为唯一不同处：内联函数会在适当的地方像定义宏一样展开，可以以空间换时间。因此，**内联函数既可以避免宏函数的缺陷，也可以避免普通函数入栈的时间浪费**
- 在普通函数函数面前加上 **inline** 关键字，否则视为普通函数
- 如果有函数声明，函数本身和声明必须同时加 **inline** 关键字，否则视为普通函数
- 任何在“类”内部定义的函数会自动成为内联函数
- 下列情况，普通函数即使指定为内联函数，编译器也可能考虑不按内联编译：
  - (1) 存在任何形式的循环语句
  - (2) 存在过多的条件判断语句
  - (3) 函数体过于庞大
  - (4) 对函数进行取址操作
- 使用方法建议：
  - (1) 内联仅仅只是给编译器一个建议，编译器不一定或接受这种建议
  - (2) 如果你没有将函数声明为内联函数，那么编译器也可能将此函数作内联编译（一个好的编译器将会内联小的，简单的函数）。因此，不用可以使用内联函数，可以交给编译器去自行处理。

## 4. 谈谈函数的重载条件

- 函数重载：在 C 语言中，函数名必须是唯一的，程序中不允许出现同名的函数。在 C++ 中是允许出现同名的函数，即在同一作用域内，具有相同函数名，不同参数列表的一组函数，称为函数重载
- 函数重载实现的原理：
  - 编译器为了实现函数重载，是做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如 void func(); 编译器可能会将函数名修饰成 func ，当编译器碰到 void func(int x)， 编译器可能将函数名修饰为 func_int, 当编译器碰到 void func(int x,char c), 编译器可能会将函数名修饰为 func_int_char ，这里使用“可能”这个字眼是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。
- 函数重载实现的条件：
  - 统一个作用域，参数的个数不同，参数的类型不同，参数的顺序不同

## 5. 谈谈 C 与 C++ 中 struct 的不同点

- C 语言中的 struct 只有数据
- C++ 中的 struct 不止有数据，还有函数

## 6. 如何理解 C++ 的密封性

- 封装特性主要包含两个方面，一个是属性和变量合成一个整体，一个是给属性和函数增加一个访问权限

## 7. 谈谈你对 C++ 构造和析构的理解

- 对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始化，对其使用后果是未知，同样的使用完一个变量，没有及时清理，也会造成一定的安全问题。 C++ 为了给我们提供这种问题的解决方案，构造函数和析构函数，这两个函数会将被编译器自动调用，完成对象初始化和对象的清理工作。
- 无论你是否喜欢，对象的初始化和清理工作是编译器强制我们要做的事情，即使你不提供初始化操作和清理操作，编译器也会给你增加默认的操作，只是这个默认初始化不会做任何事，所以编写类就应该顺便提供初始化函数。
- 构造函数主要作用在于创建对象时为对象的成员属性赋值。析构函数由编译器自动调用，无须手动调用。主要用于对象销毁前系统自动调用，执行一些清理工作。

## 8. 构造函数的分类

- 按参数类型：分为无参构造函数和有参构造函数
- 按类型分类：普通构造函数和拷贝构造函数（复制构造函数）

## 9. 构造函数的调用规则

- 默认情况下，C++ 编译器至少为我们写的类增加 3 个函数：默认构造函数（无参，函数体为空）、默认析构函数（无参，函数体为空）、默认拷贝构造函数，对类中非静态成员属性简单拷贝
- 如果用户定义构造函数， C++ 不会再提供任何默认构造函数；如果用户定义了普通构造（非拷贝）， C++ 不再提供默认无参构造，但是会提供默认拷贝构造。

## 10. 谈谈你对浅拷贝和深拷贝的区别

- 浅拷贝：同一类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为浅拷贝。一般情况下，浅拷贝没有任何副作用，但是当类中有指针，并且指针指向动态分配的内存空间，析构函数做了动态内存释放的处理，会导致内存问题。
- 深拷贝：当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要自定义拷贝构造函数，自行给指针动态分配空间，深拷贝。

## 11. 谈谈啥叫对象成员以及对象成员的构造函数调用方式

- **在类中定义的数据成员一般是基本的数据类型。但是类中的成员也可以是对象，叫对象成员。**
- C++ 中对对象的初始化是非常重要的操作，当创建一个对象的时候， C++ 编译器必须确保调用了所有子对象的构造函数。如果所有的子对象有默认，编译器可以自动调用他们。但是如果子对象没有默认的构造函数，或者想指定调用某个构造函数怎么办？那么是否可以在类的构造函数直接调用子类的属性完成初始化呢？但是如果子类的成员属性是私有的，我们是没有办法访问并完成初始化的。
- 解决办法非常简单：对于子类调用构造函数， C++ 为此提供了专门的语法，即构造函数初始化列表。 **当调用构造函数时，首先按各对象成员在类定义中的顺序（和参数列表的顺序无关）一次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体。也就是说，先调用对象成员的构造函数，再调用本身的构造函数。析构函数和构造函数调用的顺序相反，先构造，在析构。**

## 12. 谈谈你对 explicit 的理解

- C++ 提供了关键字 explicit ，禁止通过构造函数进行的隐式转换。声明为 explicit 的构造函数不能在隐式转换中使用。

## 13. 探谈 c 中 malloc free 与 c++ 中的 new delete 有啥区别，或者在 C++ 在堆区申请对象是为啥推荐使用 new delete ？

- C++ 中的 malloc free 的问题：
  - (1) 程序员必须确定对象的长度
  - (2) malloc 返回一个 void 指针， C++ 不允许将 void 赋值给其他任何指针，必须强制
  - (3) malloc 可能申请内存失败，所以必须判断返回值来确保内存分配成功
  - (4) 用户在使用对象之前必须记住对他初始化，构造函数不能显示调用初始化（构造函数是由编译器调用的），用户有可能忘记调用初始化函数
  - 总结： C 的动态内存分配太复杂，容易令人混淆，是不可接受的
- C++ 中推荐使用 new，delete
  - new 操作符能确定在调用构造函数初始化之前，所有不用显式确定调用是否成功
  - delete 表达式先调用析构函数，然后释放内存

## 14. 谈谈你对 static 静态成员变量的理解

- 在一个类中，若将一个成员函数声明为 static ，这种成员称为静态成员变量。与一般的数据成员不同，无论建立了多少个对象，都只有一个静态数据的拷贝。静态成员变量，属于某个类，所有对象共享。
- 静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间
- 注意：
  - (1) 静态成员变量必须在类中声明，在类外定义。
  - (2) 静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占空间
  - (3) 静态数据成员可以通过类名或者对象名来引用

## 15. 谈谈你对 static 静态成员函数的理解

- 在类定义中，前面有 static 说明的成员函数称为静态成员函数。静态成员函数使用方式和静态变量一样，同样在对象没有创建前，即可通过类名调用。静态成员函数主要为了访问静态变量，但是，不能访问普通成员变量。
- 静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。
- 注意：
  - (1) 静态成员函数只能访问静态变量，不能访问普通成员变量
  - (2) 静态成员函数的使用和静态成员变量一样
  - (3) 静态成员函数也有访问权限
  - (4) 普通成员函数可以访问静态成员变量，也可以访问非静态成员变量

## 16. 谈谈你对 this 的理解

- 成员函数通过 this 指针即可知道操作的是那个对象的数据。 This 指针是一种隐含指针，它隐含余每个类的非静态成员函数中。 This 指针无需定义，直接使用即可。
- 注意：静态成员函数内部没有 this 指针，静态成员函数不能操作非静态成员变量

## 17. 谈谈你对友元的理解

- 类的主要特点之一是数据隐藏，即类的私有成员无法在类的无不（作用域之外）访问。但是，有时候需要在类的外部访问类的私有成员，怎么办？解决方法是使用友元函数，友元函数是一种特权函数， C++ 允许这个特权函数访问私有成员
  - 1. friend 关键字只出现在声明处
  - 2. 其他类，类成员函数，全局函数都可以声明为友元
  - 3. 友元函数不是类的成员，不带 this 指针
  - 4. 友元函数可以访问对象任意成员属性，包括私有属性
- 友元的注意事项：
  - (1) 友元关系不能被继承
  - (2) 友元关系是单向的，类 A 是类 B 的朋友，但类 B 不一定是类 A 的朋友。
  - (3) 友元关系不具有传递性。类 B 是类 A 的朋友，类 C 是类 B 的朋友，但类 C 不一定是类 A 的朋友。
