# 基础及系统编程技术点

## 1. shell是什么

- Shell 是”命令解释器“（人和内核打交通的翻译） shell作用：对用户输入到终端的命令进行解析，调用对应的执行程序

## 2. 常见的 shell 及查看 shell 的方法

- unix 默认的 shell 为 sh
- linux 默认的 shell 为 bash
- 查看 shell 的方法： cat /etc/shells 或 echo $SHELL

## 3. 简单叙述一下 linux 下的目录结构

- /bin 存放系统可执行文件（大部分系统命令）
- /sbin 存放 root 用户的系统可执行文件
- /boot 存放内核和启动程序的相关文件
- /lib 库目录，存放系统最基本的动态库
- /meida 默认挂载设备媒体的目录，例如： U 盘、光驱
- /mnt 推荐挂载设备媒体的目录
- /usr 用于存放庞大而复杂的目录（ unix system resource ， 用于安装软件的目录）
- /porc 系统内存的映射（随着系统的运行，时长变化的）
- /etc 系统软件的启动和配置目录
- /dev 用于存放设备文件
- /home 家目录，所有用户的根目录

## 4. linux 下的权限分为哪 3 个组

- 用户权限，同组用户权限，其他用户权限

## 5. linux 文件的文件的类型

- 普通文件
- d 目录文件
- c 字符设备文件
- b 块设备文件
- l （软）连接文件
- p 管道文件
- s 本地套接字

## 6. 描述一下软链接和硬链接的区别

- 软链接： ln -s 源文件 目标文件
- 硬链接： ln 源文件 目标文件
- 软链接可以理解成快捷方式，和 windows 下的快捷方式的作用是一样的。
- 硬链接等于 cp -p 加同步更新

## 7. 谈谈你对文件描述表的理解

- 内核区-->进程管理 --> PCB 进程控制块（超⼤结构体） --> ⽂件描述符表（⽤于寻磁盘⽂件） ⼀个进程会对应⼀个⽂件描述符表，每打开⼀个⽂件会占⽤⼀个位置 ⼀个⽂件描述表本质上是⼀个数组，最多可以容纳 1024（编号： 0-1023）个⽂件描述符 前 3 个（0-2）默认是打开状态的（被占⽤），分别的标准输⼊、标准输出、标准错误

## 8. 谈谈你对程序和进程的理解

- 程序：本质：二进制文件，可以运行，但还没有运行，占用磁盘空间，不占用 CPU 和 内存（系统资源）
- 进程：本质：正在执行的程序，占用 CPU 和内存等更多的资源，一般不占用磁盘空间（I/O 操作可能会占用空间）
- 站在程序员的角度：进程是一系列指令的执行过程
- 站在操作系统的角度：进程是分配系统的资源的最小单位


## 9. 谈谈你对并行和并发的理解

- 并发：
  - 1. CPU 将 1 s 分成若干时间碎片，每个时间碎片 CPU 只能执行一个进程的一小部分
  - 2. 以时间碎片为单位，若干个进程循环占有 CPU ，并执行对应进程的一小部分
  - 3. 经过 n 次循环占有 CPU,每个进程才能执行完毕
  - 总的来说：多个进程以时间碎片为单位，循环占有 CPU ，以完成同时执行的现象称为并发
- 并行：并发发⽣在单核（只能有⼀个并发链），并⾏发⽣在多核（可以有多个并发链）

## 10. 谈谈你对 MMU （内存管理单元）的理解

- 虚拟地址映射为物理地址，以及提供硬件机制的内存

## 11. 谈谈你对 PCB （进程控制块）的理解

- PCB 中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。
- PCB 的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。或者说，OS 是根据 PCB 来对并发执行的进程进行控制和管理的。例如，当 OS 要调度某进程执行时，要从该进程的 PCB 中查处其现行状态及优先级；在调度到某进程后，要根据其 PCB 中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其 PCB 中的程序和数据的内存始址，找到其程序和数据；进程在执行过程中，当需要和与之合作的进程实现同步，通信或者访问文件时，也都需要访问 PCB；当进程由于某种原因而暂停执行时，又须将器断点的处理机环境保存在 PCB 中。
- 可见，在进程的整个生命期中，系统总是通过 PCB 对进程进行控制的，即系统是根据进程的 PCB 而不是任何别的什么而感知到该进程的存在的。所以说，PCB 是进程存在的唯一标志。

## 12. 进程的状态有几种

- 进程的状态：等待态，执行态，就绪态
- 就绪态：一切条件都具备，只差 cpu 时间片到来
- 等待态：缺少执行条件
- 执行态：cpu 时间片到来，执行程序

<center>

  ![进程状态转换图](https://595lwl.oss-cn-shenzhen.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png#pic_center)

</center>

<center>进程三种状态转换关系</center>

## 13. 谈谈你对 fork 创建的进程的数据共享模式

- fork() 后，其实是拷贝父进程内容给子进程（只有进程 pid 不同）
- 数据：刚创建子进程时，父子用户区数据完全相同，但父子后续各自进行不同操作，互不影响，各个进程的数据是独立的
- 原理解析：进程运行时候，所有的计算都在物理内存中的，父子进程“虚拟地址空间 用户区中的数据”都会通过 MMU 映射到物理内存
- 问题一：父子进程的数据都会映射到内存中，此时在内存中，会有几分数据？
  - 一份（早期的 Linux 系统设计是两份，但那种设计太浪费内存空间）
- 问题二：那如何实现父子进程的数据独立的？
  - 读时共享，写时复制（父子有一个进程对数据进行修改操作，都是先复制出一份，然后修改复制数据）
- 问题三：父子进程能否通过全局变量进行通信？
  - 不能，因为父子的全局变量是相互独立的，进程访问的都是各自的经过复制的变量，内存不能共享，无法通信。
- PCB 中的文件描述符，内存映射区是共享的。例如：父进程先打开一个文件，此时父进程文件描述符表第 3 号被占用，指向文件，此时 fork ，子进程会拷贝父进程的文件描述符，子进程也指向该文件，意味着父子进程可以操作同一个文件
- 这种设计的原因：是父子进程通过 pipe，fifo，内存映射区，套接字等实现父子进程通信的基础

## 14. 请说出啥叫僵尸进程以及孤儿进程

- 孤儿进程：不是没有爹！（会被领养） 过程：父进程先结束，子进程还运行，子进程成为孤儿进程 注意：孤儿会被 init 进程领养（ init 进程是所有孤儿进程的父进程）
- 设计领养的目地：为了子进程结束后，可以回收子进程占有的系统资源（进程结束后，子进程自己能够释放用户区空间，但无法释放 PCB 只能由父亲释放）
- 僵尸进程：是一个死的进程 过程：子进程结束，父进程没有回收 **子进程的 PCB** ，此时，子进程称为僵尸进程

## 15. 进程间的通信方式有几种？它们之间的特点？

- 无名管道，有名管道，信号，消息队列，共享内存，socket
- 管道：最简单，数据只能读取一次半双工，匿名管道只能是有血缘的关系间通信
- 命名管道：用于没有血缘关系之间的进程间通信
- 共享内存：效率高，不需要太多次的数据拷贝，可以直接进行读写，缺点是不能保证数据同步，只能借助信号量保证同步
- 信号：简单，携带的信号量少，使用在特定的场景，优先级高。建议不要使用信号进行进程间通信，因为信号的优先级高会打破原有进程的执行过程。
- socket：主要用于网络中的进程间通信，通信过程以及三数据复杂，但安全可靠。